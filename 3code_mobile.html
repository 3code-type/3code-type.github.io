<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>‰∏âÁ¢º‰∏≠ÊñáËº∏ÂÖ•Ê≥ï - ÊâãÊ©üÊªëÂãïÈÅ∏Â≠óÁâà</title>
    <link rel="preconnect" href="https://fonts.googleapis.com/">
    <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* ----------------------------------------------------- */
        /* Ê®£ÂºèÂÆöÁæ© */
        /* ----------------------------------------------------- */

        :root {
            --primary-color: #3f51b5;
            --text-color: #212121;
            --background-color: #f5f6fa;
            --container-bg: #ffffff;
            --key-bg: #f9f9f9; 
            --key-active-bg: #a0a0a0;
            --special-key-bg: #e5e5e5; 
            --border-color: #e0e0e0;
            --keyboard-bg: #aeb5b5; 
            --deep-blue: #1a237e; /* Áî®ÊñºÈ´ò‰∫ÆÁ¨¶ËôüÁöÑÊ∑±ËóçËâ≤ */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent; 
            outline: none;
        }

        body {
            font-family: 'Noto Sans TC', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--background-color);
            min-height: 100vh;
            padding-bottom: 400px; 
        }
        
        .search-area {
            width: 100%;
            max-width: 600px;
            display: flex;
            flex-wrap: wrap; 
            align-items: center;
            gap: 10px;
            padding: 8px; 
            background-color: var(--container-bg);
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            margin-bottom: 5px; 
            margin-top: 5px; 
        }

        #search-input {
            flex-grow: 0;
            width: 140px; 
            height: 40px;
            padding: 8px;
            font-size: 1.0rem; 
            border: 1px solid var(--border-color);
            border-radius: 6px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        #search-result {
            flex-grow: 1;
            min-height: 40px;
            padding: 8px;
            font-size: 1rem;
            color: #555;
            background-color: #fafafa;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            display: flex;
            align-items: center;
        }
        
        #toolbar {
            width: 100%;
            max-width: 600px;
            display: flex;
            justify-content: space-around;
            padding: 5px; 
            margin-bottom: 5px; 
        }

        #toolbar button {
            flex-grow: 1;
            margin: 0 5px;
            padding: 8px 15px; 
            font-size: 1.0rem;
            border: none;
            border-radius: 8px;
            background-color: var(--primary-color);
            color: white;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            transition: background-color 0.2s;
        }

        #toolbar button:active {
            background-color: #5c6bc0;
        }

        #app-container {
            width: 100%;
            max-width: 600px;
            padding: 5px; 
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #text-output {
            width: 100%;
            background-color: var(--container-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08);
            margin-bottom: 5px; 
            padding: 8px; 
            height: 40vh; 
            font-size: 1.5rem;
            line-height: 1.6;
            white-space: pre-wrap;
            word-break: break-word;
            color: var(--text-color);
            cursor: text; 
            overflow-y: auto; 
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        .cursor {
            display: inline-block;
            width: 0; 
            height: 1.2em; 
            vertical-align: middle;
            position: relative; 
            animation: blink 1s step-end infinite; 
        }

        .cursor::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 2px; 
            height: 100%;
            background-color: var(--primary-color); 
        }

        .composition-text {
            text-decoration: underline 2px solid var(--primary-color);
            font-weight: bold;
            display: inline;
        }
        
        #input-area {
            width: 100%;
            max-width: 600px;
            position: fixed;
            bottom: 225px; 
            left: 50%;
            transform: translateX(-50%);
            z-index: 101;
            background-color: var(--container-bg);
            border-radius: 8px 8px 0 0;
            box-shadow: 0 1px 0 var(--border-color), 0 -4px 10px rgba(0, 0, 0, 0.08);
            overflow: hidden;
            border-top: 1px solid var(--border-color); 
            border-left: 1px solid var(--border-color);
            border-right: 1px solid var(--border-color);
        }

        #main-input {
            width: 100%;
            padding: 8px;
            font-size: 1.2rem;
            min-height: 40px;
            line-height: 1.5; 
            border: none;
            border-bottom: 1px solid var(--border-color);
            background-color: #fafafa;
            color: #757575;
            white-space: nowrap;
            overflow-x: auto;
        }
        
        #candidate-display {
            display: flex;
            align-items: center;
            padding: 8px;
            gap: 12px; 
            white-space: nowrap; 
            overflow-x: scroll; 
            -webkit-overflow-scrolling: touch; 
            min-height: 60px;
            background-color: #fff;
            box-shadow: 0 1px 0 var(--border-color);
        }
        
        #candidate-display::-webkit-scrollbar {
            display: none; 
        }

        #candidate-display span {
            cursor: pointer;
            padding: 5px 8px;
            border-radius: 4px;
            transition: all 0.2s;
            user-select: none;
            white-space: nowrap;
            font-size: 1.4rem;
            flex-shrink: 0; 
            text-align: center;
        }
        
        #candidate-display span:active, #candidate-display span:hover {
            background-color: #e8eaf6;
        }
        
        /* ADDED: Toolbar item styles */
        #candidate-display span.toolbar-tool {
            font-size: 1.2rem;
            padding: 5px 15px;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
        }
        #candidate-display span.toolbar-tool:active {
            background-color: #e0e0e0;
        }
        
        #keyboard {
            width: 100%;
            max-width: 600px;
            position: fixed;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: var(--keyboard-bg); 
            padding: 5px;
            padding-bottom: env(safe-area-inset-bottom, 5px);
            user-select: none;
        }
        
        .keyboard-row {
            display: flex;
            justify-content: space-around;
            width: 100%;
            gap: 5px;
            margin-bottom: 5px;
        }

        .keyboard-key {
            display: flex;
            align-items: center;
            justify-content: center;
            flex-basis: 0; 
            flex-grow: 1;
            padding: 0;
            border-radius: 6px;
            background-color: var(--key-bg);
            border: none;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.1s;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.2); 
            position: relative;
            height: 50px; 
            font-size: 1.2rem;
            color: var(--text-color);
            min-width: 0;
        }
        
        .keyboard-key.highlighted {
            background-color: var(--key-active-bg) !important; 
            color: white;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2); 
            transform: translateY(1px); 
        }
        
        .visual-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }
        
        .alt-note {
            font-size: 0.6rem;
            color: #757575;
            position: absolute;
            top: 2px;
            right: 4px;
            line-height: 1;
        }
        
        .kbr-key-active {
            background-color: var(--primary-color) !important; 
            color: white;
            font-weight: bold;
        }
        
        .symbol-highlight {
            color: var(--deep-blue) !important; 
            font-weight: bold;
        }

        .special-key {
            background-color: var(--special-key-bg);
        }
        
        .keyboard-key:active {
             background-color: var(--key-active-bg); 
             color: white; 
             box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2); 
             transform: translateY(1px); 
        }

        .keyboard-key > .visual-wrapper > span {
            display: block;
            text-align: center;
        }
        
        .emoji button {
            border: none;
            background: none;
            font-size: 1.5rem;
            padding: 0;
            line-height: 1;
            margin: 0;
            display: inline-block;
            vertical-align: middle;
        }

        .shift-symbol {
            display: inline-block;
            transform: scaleX(2);
        }
        
        /* ADDED: Overlay styles */
        #keyboard-overlay {
            position: absolute; /* ÂÆö‰ΩçÊúÉË¢´ JS Ë¶ÜËìã */
            left: 0;
            top: 0;
            z-index: 102; /* Á¢∫‰øùÂú®ÈçµÁõ§‰∏äÊñπ */
            background-color: #fff;
            overflow: hidden;
            box-shadow: 0 1px 0 var(--border-color), 0 -4px 10px rgba(0, 0, 0, 0.08);
        }
        
        #keyboard-overlay.emoji button {
            box-sizing: border-box;
            float: left;
            text-align: center;
            font-size: 1.8rem;
        }
        
        #keyboard-overlay.editor {
            background-color: #f0f0f0;
            padding: 10px;
        }
        
        #keyboard-overlay.editor button {
            position: absolute;
            width: 20%;
            height: 18%;
            font-size: 1.2rem;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: #fff;
            transition: background-color 0.1s;
        }
        
        #keyboard-overlay.editor button:active {
            background-color: #ddd;
        }
    </style>
</head>
<body>
    
    <div class="search-area">
        <input type="text" id="search-input" placeholder="Âú®Ê≠§Ëº∏ÂÖ•ÊñáÂ≠ó" maxlength="1">
        <div id="search-result">Êü•Ë©¢ÁµêÊûúÈ°ØÁ§∫Âú®Ê≠§</div>
    </div>
    
    <div id="toolbar">
        <button id="copy-btn">üìã Ë§áË£ΩÊñáÂ≠ó</button>
        <button id="clear-btn">‚ùå Ê∏ÖÁ©∫ÊñáÂ≠ó</button>
    </div>
    
    <div id="app-container">
        <div id="text-output" spellcheck="false"></div>
    </div>
    
    <div id="input-area">
        <div id="main-input">Á∑®Á¢ºÈ°ØÁ§∫Âú®Ê≠§</div>
        <div id="candidate-display">ÂÄôÈÅ∏Â≠óÈ°ØÁ§∫Âú®Ê≠§...</div> 
    </div>
    
    <div id="keyboard">
    </div>
    <div id="keyboard-overlay" style="display:none;"></div> 

    <script>
        // --- ÁãÄÊÖãËÆäÊï∏ ---
        let currentCodemap = {};
        let currentReverseCodemap = {};
        let isEnglishMode = false; 
        let isSymbolMode = false;
        let wasInEnglishModeBeforeSymbol = false;
        let committedText = ''; 
        let cursorPosition = 0; 
        let preferredOffset = -1; 
        
        // --- Èï∑ÊåâÁõ∏ÈóúÁãÄÊÖã ---
        let longPressTimer = null;
        let longPressCommitted = false; 
        const LONG_PRESS_TIMEOUT = 750; 
        
        // --- Ê∏∏Ê®ô HTML ÂÆöÁæ© ---
        const CURSOR_HTML = '<span id="main-cursor" class="cursor">\u200c</span>';
        const NON_BREAK_ANCHOR = '\ufeff'; 
        
        // --- DOM ÂÖÉÁ¥†ÂºïÁî® ---
        const textOutput = document.getElementById('text-output');
        const mainInput = document.getElementById('main-input');
        const candidateDisplay = document.getElementById('candidate-display');
        const keyboardContainer = document.getElementById('keyboard');
        const copyButton = document.getElementById('copy-btn');
        const clearButton = document.getElementById('clear-btn');
        const searchInput = document.getElementById('search-input');
        const searchResult = document.getElementById('search-result');
        const overlayDiv = document.getElementById('keyboard-overlay');
        
        const MAX_CODE_LENGTH = 3;
        const KEY_TAG="BUTTON"; 

        // --- Key Codes ---
        const KEYCODE_SHIFT=-1;
        const KEYCODE_STATE=-2;
        const KEYCODE_SWITCH_number=-10;
        const KEYCODE_SWITCH_english=-11;
        const KEYCODE_SWITCH_index0=-14;
        const KEYCODE_SWITCH_index1=-15;
        const KEYCODE_SWITCH_index2=-16;
        
        const KEYCODE_DEL=0x08;
        const KEYCODE_ENTER=0x0d;
        const KEYCODE_SPACE=0x20;
        
        // --- ADDED: Cursor and forward delete keycodes ---
        const KEYCODE_HOME=0xff50;
        const KEYCODE_LEFT=0xff51;
        const KEYCODE_UP=0xff52;
        const KEYCODE_RIGHT=0xff53;
        const KEYCODE_DOWN=0xff54;
        const KEYCODE_DEL_F=0xff;

        // --- ÈçµÁõ§ÈÖçÁΩÆ (Áï•) ---
        var Keyboards = {
            english: {
                shifted : false,
                alt : {
                    'q':'Ôº±', 'w':'Ôº∑', 'e':'Ôº•', 'r':'Ôº≤', 't':'Ôº¥', 'y':'Ôºπ', 'u':'Ôºµ', 'i':'Ôº©', 'o':'ÔºØ', 'p':'Ôº∞',
                    'a':'Ôº°', 's':'Ôº≥', 'd':'Ôº§', 'f':'Ôº¶', 'g':'Ôºß', 'h':'Ôº®', 'j':'Ôº™', 'k':'Ôº´', 'l':'Ôº¨',
                    ';':'Ôºõ', // ÂÖ®ÂΩ¢
                    '\'':'„ÄÉ', // ÂÖ®ÂΩ¢
                    ',':'Ôºå', // ÂÖ®ÂΩ¢
                    '.':'Ôºé', // ÂÖ®ÂΩ¢
                    '/':'Ôºè', // ÂÖ®ÂΩ¢
                },
                upper: {
                    'q':'Q','w':'W','e':'E','r':'R','t':'T', 'y':'Y','u':'U','i':'I','o':'O','p':'P',
                    'a':'A','s':'S','d':'D','f':'F','g':'G', 
                    'h':'H','j':'H','k':'K','l':'L',
                    'z':'Z','x':'Z','c':'C','v':'V','b':'B', 'n':'N','m':'M',
                },
                key : [
                    [{v:'q',c:0},{v:'w',c:0},{v:'e',c:0},{v:'r',c:0},{v:'t',c:0},
                     {v:'y',c:0},{v:'u',c:0},{v:'i',c:0},{v:'o',c:0},{v:'p',c:0}],
                    [{v:'a',c:0},{v:'s',c:0},{v:'d',c:0},{v:'f',c:0},{v:'g',c:0},
                     {v:'h',c:0},{v:'j',c:0},{v:'k',c:0},{v:'l',c:0},{v:';',c:0}],
                    [{v:'‚á™',c:KEYCODE_SHIFT,r:1.5,s:true},
                     {v:'z',c:0},{v:'x',c:0},{v:'c',c:0},{v:'v',c:0},{v:'b',c:0},{v:'n',c:0},{v:'m',c:0},
                     {v:'‚å´',c:KEYCODE_DEL,r:1.5,s:true}],
                    [{v:'MODE',r:1.5,c:KEYCODE_STATE,s:true}, 
                     {v:'üåê',r:1.5,c:KEYCODE_SWITCH_number,s:true}, 
                     {v:' ',r:1.5,c:KEYCODE_SPACE,s:true},
                     {v:',',c:0},{v:'.',c:0},{v:'/',c:0},{v:'\'',c:0},
                     {v:'‚Üµ',r:1.5,c:KEYCODE_ENTER,s:true}]
                ]
            },
            number: { 
                shifted : false,
                alt : {}, 
                upper: {
                    "1":"`", "2":"~", "3":"_", "4":"^", "5":"¬±", "6":"|", "7":"[", "8":"]", "9":"{", "0":"}",
                    "@":"„Äå", "#":"„Äç", "$":"„Äé", "%":"„Äè", "&":"„Äê", "*":"„Äë", "-":"<", "+":">",
                    "(":"¬´", ")":"¬ª", "!":"¬•", "\"":"‚Ç¨", "'":"¬£", ":":"¬©", ";":"¬Æ", "/":"‚òÜ", "?":"‚òÖ"
                },
                key : [
                    [{v:'1'},{v:'2'},{v:'3'},{v:'4'},{v:'5'},
                     {v:'6'},{v:'7'},{v:'8'},{v:'9'},{v:'0'}],
                     [{v:'@'},{v:'#'},{v:'$'},{v:'%'},{v:'&'},
                     {v:'*'},{v:'-'},{v:'+'},{v:'('},{v:')'}], 
                    [{v:'‚á™',c:KEYCODE_SHIFT,r:1.5,s:true},
                     {v:'!'},{v:'"'},{v:'\''},{v:':'},{v:';'},{v:'/'},{v:'?'},
                     {v:'‚å´',c:KEYCODE_DEL,r:1.5,s:true}],
                    [{v:'MODE',r:1.5,c:KEYCODE_STATE,s:true}, 
                     {v:'üåé',r:1.5,c:KEYCODE_SWITCH_english,s:true}, 
                     {v:' ',r:2,c:KEYCODE_SPACE,s:false},
                     {v:',',s:false},{v:'.',s:false},
                     {v:'‚Üµ',r:3,c:KEYCODE_ENTER,s:true}]
                ]
            },
            number2: { 
                width:5,
                index:0,
                key0: [
                    [{v:'Êï∏Â≠ó',c:KEYCODE_SWITCH_index0,s:true},{v:'1'},{v:'2'},{v:'3'},{v:'‚å´',c:KEYCODE_DEL,s:true}],
                    [{v:'Á¨¶Ëôü',c:KEYCODE_SWITCH_index1,s:true},{v:'4'},{v:'5'},{v:'6'},{v:'‚Üµ',c:KEYCODE_ENTER,s:true}],
                    [{v:'Ë°®ÊÉÖ',c:KEYCODE_SWITCH_index2,s:true},{v:'7'},{v:'8'},{v:'9'},{v:'Á©∫Ê†º',c:KEYCODE_SPACE,s:true}],
                    [{v:'MODE',c:KEYCODE_STATE,s:true},{v:'/'},{v:'0'},{v:'.'},{v:'üåé',c:KEYCODE_SWITCH_english,s:true}] 
                ],
                key1: [
                    [{v:'Êï∏Â≠ó',c:KEYCODE_SWITCH_index0,s:true},{v:'"'},{v:'\''},{v:'~'},{v:'‚å´',c:KEYCODE_DEL,s:true}],
                    [{v:'Á¨¶Ëôü',c:KEYCODE_SWITCH_index1,s:true},{v:'$'},{v:';'},{v:'@'},{v:'‚Üµ',c:KEYCODE_ENTER,s:true}],
                    [{v:'Ë°®ÊÉÖ',c:KEYCODE_SWITCH_index2,s:true},{v:'!'},{v:'#'},{v:'%'},{v:'Á©∫Ê†º',c:KEYCODE_SPACE,s:true}],
                    [{v:'MODE',c:KEYCODE_STATE,s:true},{v:'\\'},{v:'['},{v:']'},{v:'üåé',c:KEYCODE_SWITCH_english,s:true}] 
                ],
                key2: [ 
                    [{v:'Êï∏Â≠ó',c:KEYCODE_SWITCH_index0,s:true},{v:'üòÑ'},{v:'üòÇ'},{v:'üòÉ'},{v:'‚å´',c:KEYCODE_DEL,s:true}],
                    [{v:'Á¨¶Ëôü',c:KEYCODE_SWITCH_index1,s:true},{v:'üòÖ'},{v:'üòÜ'},{v:'üòá'},{v:'‚Üµ',c:KEYCODE_ENTER,s:true}],
                    [{v:'Ë°®ÊÉÖ',c:KEYCODE_SWITCH_index2,s:true},{v:'üòâ'},{v:'üòä'},{v:'üòã'},{v:'Á©∫Ê†º',c:KEYCODE_SPACE,s:true}],
                    [{v:'MODE',c:KEYCODE_STATE,s:true},{v:'üòå'},{v:'üòç'},{v:'üòè'},{v:'üåé',c:KEYCODE_SWITCH_english,s:true}] 
                ]
            }
        };
        Keyboards.number2.keys=[Keyboards.number2.key0,Keyboards.number2.key1,Keyboards.number2.key2];
        
        let currentLayout = Keyboards.english; 
        
        function getCurrentLayoutKey() {
             if (currentLayout === Keyboards.number2) {
                 return currentLayout.keys[currentLayout.index];
             }
             return currentLayout.key;
        }

        /**
         * ÈçµÁõ§Ê∏≤ÊüìÂáΩÊï∏ (Áï•)
         */
        function drawKeyboard() {
            const layout = currentLayout;
            const layoutKey = getCurrentLayoutKey();
            const totalWidth = keyboardContainer.clientWidth;
            const layoutWidth = layout.width || 10;
            const placeHolderWidth = totalWidth / layoutWidth;
            
            keyboardContainer.innerHTML = ''; 
            
            layoutKey.forEach((row) => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'keyboard-row';
                
                row.forEach((keyData) => {
                    const key = document.createElement(KEY_TAG);
                    key.className = 'keyboard-key';
                    
                    let keyChar = keyData.v;
                    let code = keyData.c || 0;
                    const ratio = keyData.r || 1;
                    const keyWidth = placeHolderWidth * ratio;
                    
                    let displayChar = keyChar; 
                    let isSymbolShifted = false;
                    
                    if (currentLayout === Keyboards.number && code === 0) {
                        if (layout.shifted && layout.upper && layout.upper[keyChar]) {
                            displayChar = layout.upper[keyChar];
                            isSymbolShifted = true;
                        }
                    }
                    
                    // --- 1. ËôïÁêÜ QWERTY ÈçµÁöÑÈ°ØÁ§∫ÈÇèËºØ (Â≠óÊØçÂíåÊ®ôÈªû) ---
                    if (currentLayout === Keyboards.english && code === 0) {
                        
                        if (keyChar.match(/^[a-z]$/)) {
                            if (!isEnglishMode) {
                                displayChar = keyChar.toUpperCase();
                            } else {
                                if (layout.shifted) {
                                    displayChar = keyChar.toUpperCase(); 
                                } else {
                                    displayChar = keyChar;
                                }
                            }
                            
                        } else if (keyChar.match(/^[';,./]$/)) {
                            if (!isEnglishMode) {
                                displayChar = keyChar; 
                            } else {
                                 displayChar = keyChar; 
                            }
                        }
                    } 
                    
                    // --- 2. ËôïÁêÜÂäüËÉΩÈçµÊñáÂ≠ó (MODE, SHIFT Á≠âÔºåË¶ÜËìã QWERTY ÈÇèËºØ) ---
                    if (code === KEYCODE_STATE) {
                         if (currentLayout === Keyboards.english) {
                             displayChar = isEnglishMode ? 'En' : '‰∏âÁ¢º'; 
                         } else {
                             displayChar = wasInEnglishModeBeforeSymbol ? 'En' : '‰∏âÁ¢º';
                         }
                    } else if (code === KEYCODE_SHIFT) {
                        displayChar = '‚áß'; 
                    } 
                    
                    if (keyData.s) { 
                        key.classList.add('special-key');
                    }
                    
                    key.style.width = keyWidth + 'px';
                    key.dataset.code = code;
                    key.dataset.label = keyChar; 
                    
                    if (keyData.r && ratio > 1) {
                         key.style.flexGrow = ratio;
                    }
                    
                    // --- 1. ÂâµÂª∫ÂÖßÈÉ®ÂÖÉÁ¥† ---
                    const wrapper = document.createElement('span');
                    wrapper.className = 'visual-wrapper';
                    
                    const innerSymbolSpan = document.createElement('span');
                    innerSymbolSpan.innerHTML = displayChar; 
                    
                    wrapper.appendChild(innerSymbolSpan);

                    // --- 2. ËôïÁêÜ Shift ÈçµË¶ñË¶∫ ---
                    let applyScale = false;
                    
                    if (code === KEYCODE_SHIFT) {
                        innerSymbolSpan.innerHTML = layout.shifted ? '‚¨Ü' : '‚áß'; 
                        if (layout.shifted) {
                            innerSymbolSpan.classList.add('symbol-highlight'); 
                        }
                        applyScale = true;
                    } 
                    
                    if (applyScale) {
                        innerSymbolSpan.classList.add('shift-symbol'); 
                    }
                    
                    if (isSymbolShifted) {
                         innerSymbolSpan.classList.add('symbol-highlight'); 
                    }
                    
                    // --- 3. ËôïÁêÜÂÖ∂‰ªñÂäüËÉΩÈçµÁöÑËóçÂ∫ïÈ´ò‰∫Æ (number2 ÁöÑÊï∏Â≠ó/Á¨¶Ëôü/Ë°®ÊÉÖÂàáÊèõÈçµ) ---
                    if (layout === Keyboards.number2) {
                        if (layout.index === 0 && keyData.v === 'Êï∏Â≠ó') {
                            key.classList.add('kbr-key-active');
                        } else if (layout.index === 1 && keyData.v === 'Á¨¶Ëôü') {
                            key.classList.add('kbr-key-active');
                        } else if (layout.index === 2 && keyData.v === 'Ë°®ÊÉÖ') {
                            key.classList.add('kbr-key-active');
                        }
                    }

                    // Alt Note (ËºîÂä©Á¢º)
                    if (layout.alt && layout.alt[keyChar]) {
                        const altNote = document.createElement('div');
                        altNote.className = 'alt-note';
                        altNote.innerHTML = layout.alt[keyChar];
                        wrapper.appendChild(altNote);
                    }
                    
                    key.appendChild(wrapper);
                    rowDiv.appendChild(key);
                });

                keyboardContainer.appendChild(rowDiv);
            });
            
            bindKeyEvents(); 
            
            if (overlayDiv.dataset.show) {
                 // ÈáçÊñ∞Áπ™Ë£ΩÈçµÁõ§ÂæåÔºåÂ¶ÇÊûúÊµÆÂ±§ÈñãÂïüÔºåÂâáÈúÄË¶ÅÈáçÊñ∞ÂÆö‰Ωç‰∏¶Ê∏≤ÊüìÊµÆÂ±§ÂÖßÂÆπ
                 overlay(overlayDiv.className, parseInt(overlayDiv.dataset.show));
            } else if (overlayDiv.style.display !== 'none') {
                 overlayDiv.style.display = 'none';
                 overlayDiv.innerHTML = '';
            }
        }
        
        // --- ADDED: ÊµÆÂ±§ËôïÁêÜÂáΩÊï∏ ---
        
        /**
         * ËôïÁêÜË°®ÊÉÖÁ¨¶Ëôü/Á∑®ËºØÂô®ÁöÑÊµÆÂ±§È°ØÁ§∫ËàáÈö±Ëóè
         * @param {string} type - 'emoji' Êàñ 'editor'
         * @param {number|boolean} show - 0, 1 (emoji sub index) Êàñ false (hide)
         */
        function overlay(type, show) {
            // ‰ΩøÁî®ÁèæÊúâÁöÑ overlayDiv ÂÖÉÁ¥†
            const div = overlayDiv; 
            
            // Èö±Ëóè/Ê∏ÖÁêÜËàäÊµÆÂ±§
            const isShowing = div.dataset.show;
            if (isShowing) {
                div.style.display = 'none';
                div.innerHTML = '';
                delete div.dataset.show;
                // Â¶ÇÊûúÈªûÊìä‰∫ÜÁï∂ÂâçÊ≠£Âú®È°ØÁ§∫ÁöÑÊåâÈàïÔºåÂâáÈö±ËóèÂæåËøîÂõû
                if (isShowing == show && div.className == type) return;
            }

            if (show === false) return;

            // ÂèñÂæóÂ∞∫ÂØ∏
            const cand = document.getElementById('candidate-display');
            const keyboard = document.getElementById('keyboard');
            const width = keyboard.clientWidth;
            // ÊµÆÂ±§È´òÂ∫¶ = ÈçµÁõ§Á∏ΩÈ´òÂ∫¶ - ÂÄôÈÅ∏Â≠óÂàóÈ´òÂ∫¶
            const height = keyboard.clientHeight - cand.clientHeight; 

            // ÈÖçÁΩÆÊµÆÂ±§ div
            div.dataset.show = show;
            div.style.display = 'block';
            div.style.position = 'absolute'; // Á¢∫‰øùËÉΩÂÆö‰Ωç
            div.style.left = '0px'; 
            div.style.top = cand.clientHeight + 'px'; 
            div.style.width = width + 'px';
            div.style.height = height + 'px';

            const div2 = document.createElement('DIV');
            div2.style.width = width + 'px';
            div2.style.height = height + 'px';
            div2.style.overflowY = 'auto'; // ËÆìÂÖßÂÆπÂèØÊªæÂãï

            div.innerHTML = ''; // Ê∏ÖÁ©∫ÂÖßÂÆπ
            div.appendChild(div2);
            div.className = type; // ÊáâÁî® class for styling

            if (type === "emoji") {
                const emojis = [[
                    "üòÄ","üòÅ","üòÇ","üòÉ","üòÑ","üòÖ","üòÜ","üòá","üòà","üòâ",
                    "üòä","üòã","üòå","üòç","üòé","üòè","üòê","üòë","üòí","üòì",
                    "üòî","üòï","üòñ","üòó","üòò","üòô","üòö","üòõ","üòú","üòù",
                    "üòû","üòü","üò†","üò°","üò¢","üò£","üò§","üò•","üò¶","üòß",
                    "üò®","üò©","üò™","üò´","üò¨","üò≠","üòÆ","üòØ","üò∞","üò±",
                    "üò≤","üò≥","üò¥","üòµ","üò∂","üò∑","üò∏","üòπ","üò∫","üòª",
                    "üòº","üòΩ","üòæ","üòø","üôÄ","üôÅ","üôÇ","üôÉ","üôÑ","üôÖ",
                    "üôÜ","üôá","üôà","üôâ","üôä","üôã","üôå","üôç","üôé","üôè"
                ],[
                    "‚òÄ","‚òÅ","‚òé","‚òî","‚òï","‚òù","‚ò†","‚òØ","‚ôø","‚öí",
                    "‚öì","‚öî","‚ö°","‚ö™","‚ö´","‚öΩ","‚öæ","‚õÑ","‚õÖ","‚õî",
                    "‚õ™","‚õ≤","‚õ≥","‚õµ","‚õ∫","‚õΩ","‚úÖ","‚úä","‚úã","‚úå",
                    "‚ùÑ","‚ùå","‚ù§","üÜí","üÜó","üÜò","üÜô","üÜö","üåª","üåº",
                    "üåΩ","üåø","üçÅ","üçÑ","üçÖ","üçÜ","üçâ","üçå","üçç","üçì",
                    "üçî","üçï","üçö","üçú","üçü","üç¶","üç´","üç¨","üç≠","üç¥",
                    "üéÅ","üéÇ","üéÑ","üéÖ","üéà","üéì","üëå","üëç","üëé","üëè",
                    "üé®","üéØ","üé≤","üèÄ","üèÉ","üèÖ","üèÜ","üèê","üèì","üèü",
                    "üèß","üêÄ","üêÅ","üêÇ","üêÉ","üêÑ","üêÖ","üêÜ","üêá","üêà",
                    "üêâ","üêä","üêã","üêå","üêç","üêé","üêè","üêê","üêë","üêí",
                    "üêì","üêî","üêï","üêñ","üêó","üêò","üêô","üêö","üêõ","üêú",
                    "üêù","üêû","üêü","üê†","üê¢","üêß","üë£","üë´","üíä","üíã"
                ]];
                
                const emojiSet = emojis[show] || emojis[0];
                const rowLength = 10;
                const keyWidth = width / rowLength;
                
                // Ë®àÁÆóÊØèË°åÊúâÂ§öÂ∞ëÊåâÈàïÔºåÁÑ∂Âæå‰º∞ÁÆóÊØèÂÄãÊåâÈàïÁöÑÈ´òÂ∫¶
                const numRows = Math.ceil(emojiSet.length / rowLength);
                const keyHeight = height / (numRows > 0 ? numRows : 1);
                
                for (let i = 0; i < emojiSet.length; i++) {
                    const one = document.createElement('button');
                    one.textContent = emojiSet[i];
                    one.style.width = keyWidth + "px";
                    one.style.height = keyHeight + "px";
                    one.style.fontSize = '1.8rem';
                    one.style.border = 'none';
                    one.style.background = 'none';
                    one.style.margin = '0';
                    one.style.padding = '0';
                    div2.appendChild(one);
                }
                
                div2.addEventListener('click', function(e) {
                    const text = e.target.textContent;
                    // ÈÅéÊøæÊéâÂèØËÉΩÂ≠òÂú®ÁöÑÁ©∫ÁôΩ‰Ωî‰ΩçÁ¨¶
                    if (text && text.length > 0 && text !== '„ÄÄ') 
                        commitText(text); 
                });
                
            } else if (type === "editor") {
                const actions = [
                    { text: "‚Üê", left: "5%", top: "30%", click: () => handleFunctionKey(KEYCODE_LEFT, null) },
                    { text: "‚Üë", left: "20%", top: "10%", click: () => handleFunctionKey(KEYCODE_UP, null) },
                    { text: "‚Üí", left: "35%", top: "30%", click: () => handleFunctionKey(KEYCODE_RIGHT, null) },
                    { text: "‚Üì", left: "20%", top: "50%", click: () => handleFunctionKey(KEYCODE_DOWN, null) },
                    { text: "|‚Üê", left: "5%", top: "70%", click: () => handleFunctionKey(KEYCODE_HOME, null) },
                    { text: "Âà™Èô§", left: "35%", top: "70%", click: () => handleFunctionKey(KEYCODE_DEL_F, null) },
                    { text: "ÂÖ®ÈÅ∏", left: "70%", top: "5%", click: () => console.log('Editor action: selectAll (Not implemented)') },
                    { text: "Ë§áË£Ω", left: "70%", top: "27%", click: () => copyTextToClipboard() },
                    { text: "Ââ™‰∏ã", left: "70%", top: "49%", click: () => console.log('Editor action: cut (Not implemented)') },
                    { text: "Ë≤º‰∏ä", left: "70%", top: "71%", click: () => console.log('Editor action: paste (Not implemented)') }
                ];
                
                for (let i = 0; i < actions.length; i++) {
                    const one = document.createElement('button');
                    one.textContent = actions[i].text;
                    one.style.position = 'absolute';
                    one.style.left = actions[i].left;
                    one.style.top = actions[i].top;
                    one.style.width = '20%';
                    one.style.height = '18%';
                    one.addEventListener('click', actions[i].click);
                    div2.appendChild(one);
                }
            }
        }
        
        function emoji(show) {
             overlay("emoji", show);
        }

        function editor(show) {
             overlay("editor", 0);
        }
        
        // --- ADDED: Â∑•ÂÖ∑ÂàóÈÇèËºØ ---
        
        function showToolbar() {
            candidateDisplay.innerHTML = '';
            
            const toolbarItems = [
                {title:"üé§",tool:"1"},
                {title:"üòä",tool:"2"}, // Emoji 1
                {title:"‚òÄ",tool:"3"}, // Emoji 2
                {title:"üåÄ",tool:"4"}, // Placeholder
                {title:"‚áÑ",tool:"5"}, // Editor
                {title:"‚ùé",tool:"9"} // Hide/Close (ÂàáÂõû QWERTY)
            ];

            const fragment = document.createDocumentFragment();
            toolbarItems.forEach(item => {
                const span = document.createElement('span');
                span.innerHTML = item.title;
                span.dataset.tool = item.tool;
                span.classList.add("toolbar-tool"); 
                // Á∂ÅÂÆöÈªûÊìä‰∫ã‰ª∂
                span.onclick = (e) => handleToolbarClick(e.currentTarget); 
                fragment.appendChild(span);
            });
            candidateDisplay.appendChild(fragment);
        }
        
        function handleToolbarClick(target) {
            const tool = target.dataset.tool;
            if (tool === "1") { 
                 console.log('Voice input triggered (Not implemented).');
            } else if (tool === "2") {
                overlay("emoji", 0);
            } else if (tool === "3") {
                overlay("emoji", 1);
            } else if (tool === "4") {
                console.log('QR Code action triggered (Not implemented).');
            } else if (tool === "5") {
                overlay("editor", 0);
            } else if (tool === "9") {
                // Ê®°Êì¨ App.hide()ÔºåÂàáÊèõÂõû QWERTY (Ëã±ÊñáÊ®°Âºè/‰∏âÁ¢ºÊ®°Âºè)
                handleFunctionKey(KEYCODE_SWITCH_english, 'üåê'); 
            }
        }
        
        /**
         * ËôïÁêÜÈï∑Êåâ‰∫ã‰ª∂ÔºöÊèê‰∫§ËºîÂä©Â≠óÁ¨¶ (Áï•)
         */
        function handleLongPress(keyElement, altChar) {
            longPressCommitted = true; 
            keyElement.classList.remove('highlighted');
            
            // Êèê‰∫§ËºîÂä©Â≠óÂÖÉ (altChar ÊòØÂÖ®ÂΩ¢)
            commitText(altChar); 
        }

        /**
         * ËôïÁêÜÁü≠Êåâ‰∫ã‰ª∂ÔºöÂü∑Ë°åÁ∑®Á¢ºÊàñÊôÆÈÄöÂ≠óÁ¨¶Ëº∏ÂÖ• (Áï•)
         */
        function handleShortPress(keyElement) {
            preferredOffset = -1; 
            let code = parseInt(keyElement.dataset.code);
            let keyChar = keyElement.dataset.label; 

            if (code === 0) { 
                let charToCommit = keyChar;
                
                if (currentLayout.shifted && currentLayout.upper && currentLayout.upper[keyChar]) {
                    charToCommit = currentLayout.upper[keyChar];
                } 
                
                if (isEnglishMode && currentLayout === Keyboards.english) {
                    if (keyChar.match(/^[';,./]$/)) {
                        handleCharInput(keyChar);
                        return;
                    }
                }
                
                if (!isEnglishMode && !isSymbolMode) {
                     if (keyChar.match(/^[a-z]$/i) || keyChar.match(/^[';,./]$/)) {
                         handleChineseInput(keyChar.toLowerCase());
                         return;
                     }
                 }
                
                handleCharInput(charToCommit); 
                return;
            }
            
            // ËôïÁêÜÂäüËÉΩÈçµ
            handleFunctionKey(code, keyChar);
        }
        
        /**
         * ËôïÁêÜÂäüËÉΩÈçµÈÇèËºØ (Â∑≤Êñ∞Â¢ûÊ∏∏Ê®ôÊéßÂà∂)
         */
        function handleFunctionKey(code, keyChar) {
             // Á¢∫‰øùÂú®ËôïÁêÜÂäüËÉΩÈçµÊôÇÈö±ËóèÊµÆÂ±§
             overlayDiv.style.display = 'none';
             delete overlayDiv.dataset.show;
             
             switch(code) {
                case KEYCODE_SHIFT:
                    const newShiftState = !Keyboards.english.shifted; 
                    Keyboards.english.shifted = newShiftState;
                    Keyboards.number.shifted = newShiftState; 
                    if (currentLayout === Keyboards.english || currentLayout === Keyboards.number) {
                        currentLayout.shifted = newShiftState;
                    }

                    drawKeyboard();
                    break;
                case KEYCODE_STATE:
                    if (currentLayout === Keyboards.english) {
                        isEnglishMode = !isEnglishMode;
                        wasInEnglishModeBeforeSymbol = isEnglishMode; 
                        isSymbolMode = false;
                    } else {
                        wasInEnglishModeBeforeSymbol = !wasInEnglishModeBeforeSymbol;
                    }
                    drawKeyboard();
                    resetInputState(); 
                    break;
                case KEYCODE_SWITCH_number: 
                    if (currentLayout === Keyboards.english) {
                        wasInEnglishModeBeforeSymbol = isEnglishMode; 
                    }
                    isSymbolMode = true;
                    isEnglishMode = false; 
                    currentLayout = Keyboards.number; 
                    drawKeyboard();
                    resetInputState();
                    break;
                case KEYCODE_SWITCH_english: 
                    isSymbolMode = false;
                    isEnglishMode = wasInEnglishModeBeforeSymbol; 
                    currentLayout = Keyboards.english;
                    drawKeyboard();
                    resetInputState();
                    break;
                case KEYCODE_SWITCH_index0: 
                case KEYCODE_SWITCH_index1: 
                case KEYCODE_SWITCH_index2: 
                     if(currentLayout === Keyboards.number2) {
                         currentLayout.index = code - KEYCODE_SWITCH_index0; 
                         drawKeyboard();
                     }
                     break;
                case KEYCODE_DEL:
                    backspaceOutput();
                    break;
                case KEYCODE_ENTER:
                    if (isEnglishMode || isSymbolMode) {
                        commitText('\n');
                    } else {
                        handleChineseInput('enter');
                    }
                    break;
                case KEYCODE_SPACE:
                    if (isEnglishMode || isSymbolMode) {
                        commitText(' ');
                    } else {
                        handleChineseInput(' ');
                    }
                    break;
                
                // --- ADDED: Ê∏∏Ê®ôÊéßÂà∂ÈÇèËºØ ---
                case KEYCODE_LEFT:
                     if (cursorPosition > 0) {
                         cursorPosition--;
                         updateOutputDisplay();
                     }
                     break;
                case KEYCODE_RIGHT:
                     if (cursorPosition < committedText.length) {
                         cursorPosition++;
                         updateOutputDisplay();
                     }
                     break;
                case KEYCODE_UP:
                case KEYCODE_DOWN:
                     // Á∞°ÂåñËôïÁêÜÔºöÂú®Ê≤íÊúâÂÆåÊï¥Á∑®ËºØÂô®ÈÇèËºØÊôÇÔºå‰∏ä‰∏ãÈçµÊö´ÊôÇÊ®°Êì¨Â∑¶Âè≥ÁßªÂãï
                     if (code === KEYCODE_UP && cursorPosition > 0) {
                         cursorPosition--;
                         updateOutputDisplay();
                     } else if (code === KEYCODE_DOWN && cursorPosition < committedText.length) {
                         cursorPosition++;
                         updateOutputDisplay();
                     }
                     break;
                case KEYCODE_HOME:
                     cursorPosition = 0;
                     updateOutputDisplay();
                     break;
                case KEYCODE_DEL_F: // Forward Delete
                     if (cursorPosition < committedText.length) {
                         committedText = committedText.slice(0, cursorPosition) + committedText.slice(cursorPosition + 1);
                         updateOutputDisplay();
                     }
                     break;
                // --- END ADDED ---
                     
                default:
                    console.log('Unhandled keycode:', code);
                    break;
            }
        }
        
        /**
         * Áµ±‰∏ÄÁöÑ‰∫ã‰ª∂Á∂ÅÂÆöÂáΩÊï∏ (Áï•)
         */
        function bindKeyEvents() {
            document.querySelectorAll('.keyboard-key').forEach(keyElement => {
                
                if (keyElement.handlePressDown) {
                    keyElement.removeEventListener('touchstart', keyElement.handlePressDown);
                    keyElement.removeEventListener('touchend', keyElement.handlePressUp);
                    keyElement.removeEventListener('touchcancel', keyElement.handlePressCancel);
                    keyElement.removeEventListener('mousedown', keyElement.handlePressDown);
                    keyElement.removeEventListener('mouseup', keyElement.handlePressUp);
                    keyElement.removeEventListener('mouseleave', keyElement.handlePressCancel);
                }
                
                keyElement.onclick = null; 
                keyElement.oncontextmenu = (e) => e.preventDefault(); 
                
                const keyChar = keyElement.dataset.label;
                const altChar = currentLayout.alt ? currentLayout.alt[keyChar] : null; 
                
                const handlePressDown = (event) => {
                    if (event.type === 'mousedown' && event.button !== 0) return;
                    if (event.type.startsWith('touch')) event.preventDefault(); 
                    
                    longPressCommitted = false; 
                    keyElement.classList.add('highlighted');

                    if (currentLayout === Keyboards.english && altChar) {
                        if (longPressTimer) clearTimeout(longPressTimer);
                        longPressTimer = setTimeout(() => {
                            handleLongPress(keyElement, altChar);
                        }, LONG_PRESS_TIMEOUT);
                    }
                };
                
                const handlePressUp = (event) => {
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                    }
                    
                    if (!longPressCommitted) { 
                        handleShortPress(keyElement);
                    }
                    
                    keyElement.classList.remove('highlighted');
                    longPressCommitted = false;
                };
                
                const handlePressCancel = (event) => {
                     if (longPressTimer) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                    }
                     if (event.type === 'mouseleave' || event.type === 'touchcancel') {
                         keyElement.classList.remove('highlighted');
                     }
                };

                keyElement.handlePressDown = handlePressDown;
                keyElement.handlePressUp = handlePressUp;
                keyElement.handlePressCancel = handlePressCancel;

                keyElement.addEventListener('touchstart', handlePressDown);
                keyElement.addEventListener('touchend', handlePressUp);
                keyElement.addEventListener('touchcancel', handlePressCancel); 
                
                keyElement.addEventListener('mousedown', handlePressDown);
                keyElement.addEventListener('mouseup', handlePressUp);
                keyElement.addEventListener('mouseleave', handlePressCancel); 
            });
        }
        
        /**
         * ËôïÁêÜÂñÆÂ≠óÁ¨¶Ëº∏ÂÖ• (Áî®ÊñºËã±Êñá/Á¨¶ËôüÊ®°ÂºèÊàñ Shift+Â≠óÊØç) (Áï•)
         */
        function handleCharInput(char) {
             if (currentLayout.shifted) {
                 commitText(char);
            } else if (isEnglishMode || isSymbolMode) {
                 commitText(char);
            } else if (currentLayout === Keyboards.number || currentLayout === Keyboards.number2) {
                 commitText(char);
            } else {
                 commitText(char);
            }
        }
        
        // --- Ê†∏ÂøÉËº∏ÂÖ•Ê≥ïÈÇèËºØ (ÂÖ∂È§òÈÉ®ÂàÜÁï•) ---
        
        var currentCode = '';
        var currentCandidates = [];

        function formatCode(code) {
            let displayString = '';
            const map = {
                ';':'Ôºõ', 
                '\'':'„ÄÉ', 
                ',':'Ôºå', 
                '.':'Ôºé', 
                '/':'Ôºè', 
            }; 
            
            for (const char of code) {
                if (char.match(/^[a-z]$/)) {
                    const upperCaseChar = char.toUpperCase();
                    const fullwidthChar = String.fromCharCode(upperCaseChar.charCodeAt(0) - 0x20 + 0xFF00);
                    displayString += fullwidthChar;
                } else if (map[char]) {
                    displayString += map[char];
                } else {
                    displayString += char;
                }
            }
            return displayString;
        }

        function formatComposition(code) {
            if (!code) return '';
            let displayString = formatCode(code);
            return `<span class="composition-text">${displayString}</span>`;
        }
        
        function updateOutputDisplay() {
            const softWrapPoints = []; 
            
            let outputHtml = '';
            let currentPos = 0;
            
            let compositionHtml = '';
            if (!isEnglishMode && !isSymbolMode && currentCode.length > 0) {
                compositionHtml = formatComposition(currentCode);
            } 
            
            const fullTextLength = committedText.length;

            while (currentPos <= fullTextLength) {
                
                if (softWrapPoints.includes(currentPos)) {
                    if (currentPos > 0 && committedText[currentPos - 1] !== '\n') {
                         outputHtml += NON_BREAK_ANCHOR; 
                    }
                }

                if (currentPos === cursorPosition) {
                    outputHtml += compositionHtml + CURSOR_HTML; 
                    compositionHtml = ''; 
                }
                
                if (currentPos < fullTextLength) {
                    const char = committedText[currentPos];
                    if (char === '\n') {
                        outputHtml += '<br>';
                    } else {
                        outputHtml += char; 
                    }
                }
                
                currentPos++;
            }

            textOutput.innerHTML = outputHtml;

            const cursorElement = document.getElementById('main-cursor');
            if (cursorElement) {
                cursorElement.scrollIntoView({ behavior: 'auto', block: 'nearest' });
            }
        }

        function commitText(textToCommit) {
            committedText = committedText.slice(0, cursorPosition) + textToCommit + committedText.slice(cursorPosition);
            cursorPosition += textToCommit.length; 
            preferredOffset = -1; 
            resetInputState();
        }

        function backspaceOutput() {
            if (!isEnglishMode && !isSymbolMode && currentCode.length > 0) {
                 currentCode = currentCode.slice(0, -1);
                 updateStateAndDisplay();
            } else if (cursorPosition > 0) {
                committedText = committedText.slice(0, cursorPosition - 1) + committedText.slice(cursorPosition);
                cursorPosition -= 1;
                preferredOffset = -1;
                updateOutputDisplay();
                resetInputState(); 
            }
        }
        
        function parseCinData(data) { 
            const newCodemap = {};
            const newReverseCodemap = {};
            const lines = data.trim().split('\n');
            lines.forEach(line => {
                const parts = line.split('\t');
                if (parts.length >= 2 && !line.startsWith('#')) {
                    const code = parts[0].trim();
                    const char = parts[1].trim(); 
                    if (code && char) {
                        if (!newCodemap[code]) {
                            newCodemap[code] = [];
                        }
                        newCodemap[code].push(char);
                        
                        if (!newReverseCodemap[char]) {
                            newReverseCodemap[char] = [];
                        }
                        if (!newReverseCodemap[char].includes(code)) {
                             newReverseCodemap[char].push(code);
                        }
                    }
                }
            });
            return { newCodemap, newReverseCodemap };
        }

        async function loadSecondaryCodemap() {
            const fileName = './3codes2.txt'; 
            let textToParse = `# ÈÄôÊòØÂÇôÁî®ÁöÑÊ®°Êì¨Á∑®Á¢ºË°® (Áî®ÊñºÊ∏¨Ë©¶)\nÊ∏¨\tqwe\nË©¶\trty\nÂ∑•\taaa\nÂ§´\tqwe\n„Äå\t;'\n„Äç\t';\nÈÄô\tqwe\n`; 
            let statusMessage = 'Á∑®Á¢ºË°®ËºâÂÖ•‰∏≠...'; 

            try {
                const response = await fetch(fileName);
                if (!response.ok) {
                     throw new Error(`ÁÑ°Ê≥ïËºâÂÖ•Â§ñÈÉ®Ê™îÊ°à (${response.status})„ÄÇ`);
                }
                const responseText = await response.text();
                if (responseText.trim().replace(/^#.*$/gm, '').trim().length > 0) {
                    textToParse = responseText;
                }
                statusMessage = `Â∑≤ÊàêÂäüËºâÂÖ• ${fileName} (Âê´ÂèçÊü•Á¢º)`;
            } catch (error) {
                console.error('Â§ñÈÉ®Ê™îÊ°àËÆÄÂèñÈåØË™§:', error.message);
                statusMessage = `ËºâÂÖ• ${fileName} Â§±ÊïóÔºåÂ∑≤ÂàáÊèõËá≥ÂÇôÁî®Á∑®Á¢º„ÄÇ`;
            }
            
            try {
                const { newCodemap, newReverseCodemap } = parseCinData(textToParse);
                currentCodemap = newCodemap;
                currentReverseCodemap = newReverseCodemap;
            } catch (e) {
                currentCodemap = {};
                currentReverseCodemap = {};
                statusMessage = 'ÈåØË™§ÔºöÁ∑®Á¢ºË°®Ëß£ÊûêÂ§±Êïó„ÄÇ';
            }
            
            resetInputState();
            updateOutputDisplay();
        }

        function handleChineseInput(code) {
            const inputChar = code.toLowerCase();
            
            if (inputChar === 'enter') {
                if (currentCandidates.length > 0) {
                    selectCandidate(0); 
                } else {
                    commitText('\n'); 
                }
                return;
            }
            if (inputChar === ' ') {
                if (currentCandidates.length > 0) {
                    selectCandidate(0); 
                } else {
                    commitText('„ÄÄ');
                }
                return;
            }
            
            if (inputChar.match(/^[a-z0-9;'./,<>]$/)) {
                if (currentCode.length === MAX_CODE_LENGTH) {
                    if (currentCandidates.length > 0) {
                        selectCandidate(0); 
                    }
                    currentCode = inputChar;
                } else {
                    currentCode += inputChar;
                }
                updateStateAndDisplay();
            }
        }
        
        function updateStateAndDisplay() {
            mainInput.textContent = formatCode(currentCode); 
            currentCandidates = currentCodemap[currentCode] || [];
            
            if (currentCode.length === MAX_CODE_LENGTH) {
                if (currentCandidates.length === 1) {
                    commitText(currentCandidates[0]);
                    return;
                }
            }
            
            updateOutputDisplay();
            showCandidates();
        }
        
        function selectCandidate(index) {
             if (index < currentCandidates.length) {
                 commitText(currentCandidates[index]);
             }
        }
        
        /**
         * È°ØÁ§∫ÂÄôÈÅ∏Â≠óÊàñÂ∑•ÂÖ∑Âàó (‰øÆÊ≠£ÔºöÁ¢∫‰øùÁÑ°Á∑®Á¢ºÊôÇÈ°ØÁ§∫Â∑•ÂÖ∑ÂàóÔºåËÄå‰∏çÊòØÊ®°ÂºèË®äÊÅØ)
         */
        function showCandidates() {
            candidateDisplay.innerHTML = '';
            
            // 1. Â¶ÇÊûúÊµÆÂ±§ÈñãÂïüÔºåÂÑ™ÂÖàËôïÁêÜÊµÆÂ±§ÔºåÊ∏ÖÁ©∫È°ØÁ§∫ÂçÄ
            if (overlayDiv.dataset.show) {
                 candidateDisplay.textContent = '';
                 return;
            }
            
            // 2. Â¶ÇÊûúÊ≤íÊúâÊ≠£Âú®Ëº∏ÂÖ•ÁöÑÁ∑®Á¢º (ÁÑ°Ë´ñÊòØÂê¶Âú®Ëã±Êñá/Á¨¶ËôüÊ®°Âºè)ÔºåÈ°ØÁ§∫Â∑•ÂÖ∑Âàó
            if (currentCode.length === 0) {
                 showToolbar();
                 return;
            }

            // 3. Â¶ÇÊûúÂú®Ëã±ÊñáÊàñÁ¨¶ËôüÊ®°Âºè‰∏ãÔºå‰ΩÜÊúâÁ∑®Á¢ºÔºàÈÄôÈÄöÂ∏∏‰∏çÊúÉÁôºÁîüÔºåÈô§ÈùûÂæû‰∏âÁ¢ºÊ®°ÂºèÂàáÊèõÈÅé‰æÜÔºâÔºåÈ°ØÁ§∫Ê®°ÂºèÁãÄÊÖã
            if (isSymbolMode || isEnglishMode) {
                 candidateDisplay.textContent = isSymbolMode ? 'Á¨¶ËôüÊ®°Âºè' : 'Ëã±ÊñáÊ®°Âºè';
                 return;
            }

            // 4. ËôïÁêÜ‰∏≠ÊñáËº∏ÂÖ•Ê≥ïÁöÑÂÄôÈÅ∏Â≠ó
            if (currentCandidates.length === 0) {
                 candidateDisplay.textContent = `ÁÑ°ÂÄôÈÅ∏Â≠ó (${formatCode(currentCode)})`;
                 return;
            }

            currentCandidates.forEach((candidate, index) => {
                const span = document.createElement('span');
                span.textContent = candidate; 
                span.onclick = () => selectCandidate(index); 
                candidateDisplay.appendChild(span);
            });
            
            candidateDisplay.scrollLeft = 0;
        }
        
        function resetInputState() {
            currentCode = '';
            currentCandidates = [];
            
            if (isSymbolMode) {
                 mainInput.textContent = 'Á¨¶ËôüÊ®°Âºè';
            } else if (isEnglishMode) { 
                 mainInput.textContent = 'Ëã±ÊñáÊ®°Âºè';
            } else {
                 mainInput.textContent = 'Á∑®Á¢ºÈ°ØÁ§∫Âú®Ê≠§';
            }
            
            showCandidates();
            updateOutputDisplay(); 
        }

        // --- Â∑•ÂÖ∑ÂàóËàáÊü•Á¢ºÂäüËÉΩ (Áï•) ---

        function copyTextToClipboard() {
            const textToCopy = committedText; 
            if (!textToCopy) {
                alert('Ëº∏Âá∫ÂçÄÊ≤íÊúâÊñáÂ≠óÂèØ‰ª•Ë§áË£ΩÔºÅ');
                return;
            }
            
            if (navigator.clipboard) {
                navigator.clipboard.writeText(textToCopy).then(() => {
                    alert('ÊñáÂ≠óÂ∑≤ÊàêÂäüË§áË£ΩÂà∞Ââ™Ë≤ºÁ∞øÔºÅ');
                }).catch(err => {
                    console.error('Ë§áË£ΩÂ§±Êïó: ', err);
                    alert('Ë§áË£ΩÂ§±ÊïóÔºåË´ãÊâãÂãïÈÅ∏Âèñ„ÄÇ');
                });
            } else {
                const tempInput = document.createElement('textarea');
                tempInput.value = textToCopy;
                document.body.appendChild(tempInput);
                tempInput.select();
                try {
                    document.execCommand('copy');
                    alert('ÊñáÂ≠óÂ∑≤ÊàêÂäüË§áË£ΩÂà∞Ââ™Ë≤ºÁ∞øÔºÅ');
                } catch (err) {
                    alert('Ë§áË£ΩÂ§±ÊïóÔºåË´ãÊâãÂãïÈÅ∏ÂèñÊñáÂ≠ó„ÄÇ');
                }
                document.body.removeChild(tempInput);
            }
            resetInputState();
        }
        
        function clearOutput() {
            if (confirm('Á¢∫ÂÆöË¶ÅÊ∏ÖÁ©∫ÊâÄÊúâÂ∑≤Ëº∏ÂÖ•ÁöÑÊñáÂ≠óÂóéÔºü')) {
                committedText = ''; 
                cursorPosition = 0;
                preferredOffset = -1;
                resetInputState();
            }
        }
        function handleSearchInput(event) {
            const charToSearch = searchInput.value;
            if (charToSearch.length === 1) {
                const codes = currentReverseCodemap[charToSearch];
                if (codes && codes.length > 0) {
                    const formattedCodes = codes.map(code => formatCode(code));
                    searchResult.textContent = `Á∑®Á¢ºÔºö„ÄÄ${formattedCodes.join('„ÄÄ')}`;
                } else {
                    searchResult.textContent = 'Êâæ‰∏çÂà∞Ë©≤Â≠óÁ¨¶ÁöÑÁ∑®Á¢º„ÄÇ';
                }
            } else {
                searchResult.textContent = 'Êü•Ë©¢ÁµêÊûúÈ°ØÁ§∫Âú®Ê≠§';
            }
        }
        function handleSearchKeydown(event) { if (event.key === 'Backspace') { event.stopPropagation(); } }
        
        function mapDOMOffsetToTextIndex(targetNode, targetOffset) {
            let committedIndex = 0;
            const outputDiv = document.getElementById('text-output');
            
            const walker = document.createTreeWalker(
                outputDiv,
                NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT,
                { acceptNode: (node) => {
                     if (node.nodeType === Node.ELEMENT_NODE && (node.classList.contains('cursor') || node.classList.contains('composition-text'))) {
                         return NodeFilter.FILTER_SKIP;
                     }
                     return NodeFilter.FILTER_ACCEPT;
                }},
                false
            );

            let node;
            while (node = walker.nextNode()) {
                if (node.nodeType === Node.TEXT_NODE) {
                    const textContent = node.textContent;
                    
                    if (node === targetNode) {
                        let count = 0;
                        for (let i = 0; i < targetOffset; i++) {
                            const char = textContent[i];
                            if (char !== NON_BREAK_ANCHOR && char !== '\u200c') {
                                count++;
                            }
                        }
                        committedIndex += count;
                        return committedIndex; 
                    }
                    
                    for (const char of textContent) {
                        if (char !== NON_BREAK_ANCHOR && char !== '\u200c') {
                            committedIndex++;
                        }
                    }
                    
                } else if (node.nodeName === 'BR') {
                    committedIndex++; 
                } 
            }

            return committedText.length;
        }

        function handleTextTap(event) {
            event.preventDefault(); 
            
            const x = event.clientX || (event.changedTouches && event.changedTouches[0].clientX);
            const y = event.clientY || (event.changedTouches && event.changedTouches[0].clientY);
            
            if (x === undefined || y === undefined) return;

            let targetPosition;
            
            if (document.caretPositionFromPoint) {
                targetPosition = document.caretPositionFromPoint(x, y);
            } else if (document.caretRangeFromPoint) {
                targetPosition = document.caretRangeFromPoint(x, y);
            }

            if (targetPosition) {
                let newNode, newOffset;

                if (targetPosition instanceof CaretPosition) {
                    newNode = targetPosition.offsetNode;
                    newOffset = targetPosition.offset;
                } else if (targetPosition instanceof Range) {
                    newNode = targetPosition.endContainer;
                    newOffset = targetPosition.offset;
                }

                if (newNode && textOutput.contains(newNode)) {
                    const newCursorPos = mapDOMOffsetToTextIndex(newNode, newOffset);
                    
                    if (newCursorPos !== cursorPosition) {
                        cursorPosition = newCursorPos;
                        preferredOffset = -1; 
                        updateOutputDisplay();
                    }
                } else if (newNode === textOutput && newOffset === textOutput.childNodes.length) {
                    if (cursorPosition !== committedText.length) {
                         cursorPosition = committedText.length;
                         preferredOffset = -1;
                         updateOutputDisplay();
                    }
                }
            }
        }


        // È†ÅÈù¢ÂïüÂãï
        document.addEventListener('DOMContentLoaded', () => {
            drawKeyboard(); 
            loadSecondaryCodemap(); 
            
            textOutput.addEventListener('click', handleTextTap);
            textOutput.addEventListener('touchend', handleTextTap);
            
            copyButton.addEventListener('click', copyTextToClipboard);
            clearButton.addEventListener('click', clearOutput);
            
            searchInput.addEventListener('input', handleSearchInput);
            searchInput.addEventListener('keydown', handleSearchKeydown);
        });
        
    </script>
</body>
</html>